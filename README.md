# Purpose of the Database
The database generated by `create_tables.py` enables Sparkify to efficiently analyze the user data relating to user activity whilst using their app. Specifically, it optimises the analysis of what users are listening to.

# Architectural decisions 
State and justify your database schema design and ETL pipeline.

Using a star schema simplifies the queries and allows fast aggregations. The tables are structured such that a member of the analytics team can quickly identify the total number of songs played by a user using a single join. Similarly, one could also return an artist's most popular song using only 2 joins (The second being significantly shorter).

## Decisions for tables
In the explore notebook I've consolidated the queries I've used to determine the datatypes for each column in a table. I created a function find_min_max that returns:
- min and max value of a column if its a number.
  - if it's a float, it also returns the number of digits before and after the decimal place.
- min and max of a string.

## Artists Table {#artists-table}
- **artist_id**: All artist ID's are 18 characters long.
- **name**: Names can be arbitrary lengths. A quick google search shows the longest name musical duo's name to be 31 characters long (Bj√∂rn Ulvaeus & Benny Andersson). Longer still there is a band with a 58 character long name (The Rock and Roll Dubble Bubble Trading Card Co. of Philadelphia - 19141). Now if we to the extreme, the longest recorded name in the world is Hubert B. Wolfe + 988 Sr. (988 being the length of surname), but that's ridiculous and even then it has a shortened version. So I chose 100 characters (33% higher).
- **location**: The longest city/town name in the world is in New Zeland with a length of 86 characters. Due to the addition to any other location information (country, region, state, etc), I set the length of the varchar to be 255.
- **latitude**: Numeric with 8 values (5 after decimal place)
- **longitude**: Numeric with 19 values (15 after decimal place)

## Users Table {#users-table}
- **user_id**: just an integer meaning the number of possible unique ids is over 2 billon.
- **title**: 255 characters, because a song can be called anything
- **firt_name** & **last_name**: Varchars of 100 characters as discussed in [Artists Table](#artists-table)
- **gender**: the max length of the genders is 4 characters in the data (male & female), however accounting for any more genders that may be added we set it to 50
- **level**: the max length of the level is 4 characters in the data (free & paid), however accounting for any more levels that may be added we set it to 50

## Songs Table {#songs-table}
- **song_id**: All song ID's are 18 characters long.
- **title**: Titles are arbitrary lengths so 255 varchar characters here.
- **artist_id**: same as id in artists table as its a foreign key.
- **year**: because that will take us to the year 32,767.
- **duration**: Numeric with 11 values (5 after decimal place) because they all had that format in the test data

## Time Table {#time-table}
I assumed that the purpose of the time table was to simplify queries when creating search windows, so the hour, day, week, month and year values are all integers. and the primary key is just a timestamp to hold the original timestamp.

## Songplay Table {#songplay-table}
- **songplay_id**: Every song added to the table needs to be a unique id, so the type is set to serial so that the id will increment upon each addition.
- **start_time**, **user_id**, **song_id** & **artist_id**: all are foreign keys and use the same format from originals keys.
- **level**: not a foreign key, but should still be the same as in the users table
- **session_id**: the min number is 3 and max is 1114. Assuming there are going to be millions of sessions I used a datatype integer.
- **location**: same as in [Artists Table](#artists-table) the location is a 255 length varchar.
- **user_agent**: the maximum length of a user agent was 139, so we set the varchar length to 255 allowing for longer user agents.


# Optional: Query examples for song play analysis
For each artist I want to list their songs by most played to least played. However, as the data I have is an incomplete dataset, instead I'll simulate this using a similar query. For each user, return the sessions in order of the total number of songs listened to, from most to least. 


```SQL
SELECT first_name, last_name, songs_in_session 
FROM users 
	JOIN 
	(SELECT COUNT(session_id) as songs_in_session, user_id 
	FROM songplays
		JOIN time on songplays.start_time = time.start_time
	
	GROUP BY user_id, session_id 
	ORDER BY user_id, songs_in_session DESC) 
AS us ON users.user_id = us.user_id;
```

By David Attlee